function [img_polar, noise_mask] = normalizza_iride(img_red, c_pupil, r_pupil, c_iris, r_iris, h_out, w_out)

%% NORMALIZZAZIONE IRIDE: Daugman Rubber Sheet Model.

    if nargin < 6
        h_out = 64;  % Altezza standard (risoluzione radiale)
        w_out = 512; % Larghezza standard (risoluzione angolare)
    end

    % Angolo theta e raggio
    theta = linspace(0, 2*pi, w_out);
    radius = linspace(0, 1, h_out);
    
    % Coordinate bordo pupilla e iride
    xp = c_pupil(1) + r_pupil * cos(theta);
    yp = c_pupil(2) + r_pupil * sin(theta);
    xi = c_iris(1) +  r_iris * cos(theta);
    yi = c_iris(2) +  r_iris * sin(theta);
    
    % Interpolazione
    % Creiamo matrici per vettorizzare il calcolo
    xp_mat = repmat(xp, h_out, 1);
    yp_mat = repmat(yp, h_out, 1);
    xi_mat = repmat(xi, h_out, 1);
    yi_mat = repmat(yi, h_out, 1);
    
    r_mat = repmat(radius', 1, w_out); % Trasposto perchÃ© radius varia sulle righe
    
    % Formula di Daugman:
    x_grid = (1 - r_mat) .* xp_mat + r_mat .* xi_mat;
    y_grid = (1 - r_mat) .* yp_mat + r_mat .* yi_mat;
    
    % Estrazione pixel
    img_double = double(img_red);
    [rows, cols] = size(img_red);
    [X, Y] = meshgrid(1:cols, 1:rows);
    img_polar = interp2(X, Y, img_double, x_grid, y_grid, 'linear');
    
    % Gestione NaN (se l'iride esce dai bordi della foto)
    noise_mask = ~isnan(img_polar);
    img_polar(isnan(img_polar)) = 0; % Mettiamo a nero i punti mancanti
    
    % Convertiamo in uint8 per visualizzazione
    img_polar = uint8(img_polar);

end